"use strict";(self.webpackChunkflex_project_template_docs=self.webpackChunkflex_project_template_docs||[]).push([[3451],{20918:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/flex-user-experience-omni-channel-capacity-management-6f201542a8a932998f5789ee1f1c866a.gif"},28453:(e,a,t)=>{t.d(a,{R:()=>c,x:()=>r});var n=t(96540);const i={},s=n.createContext(i);function c(e){const a=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(s.Provider,{value:a},e.children)}},52887:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"feature-library/omni-channel-capacity-management","title":"omni-channel-capacity-management","description":"This feature is intended for use when the solution imposes the following parameters","source":"@site/docs/feature-library/omni-channel-capacity-management.md","sourceDirName":"feature-library","slug":"/feature-library/omni-channel-capacity-management","permalink":"/feature-library/omni-channel-capacity-management","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"omni-channel-capacity-management","title":"omni-channel-capacity-management"},"sidebar":"tutorialSidebar","previous":{"title":"multi-call","permalink":"/feature-library/multi-call"},"next":{"title":"park-interaction","permalink":"/feature-library/park-interaction"}}');var i=t(74848),s=t(28453);const c={sidebar_label:"omni-channel-capacity-management",title:"omni-channel-capacity-management"},r=void 0,o={},l=[{value:"flex-user-experience",id:"flex-user-experience",level:2},{value:"setup and dependencies",id:"setup-and-dependencies",level:2},{value:"how does it work?",id:"how-does-it-work",level:2}];function h(e){const a={h2:"h2",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.p,{children:"This feature is intended for use when the solution imposes the following parameters"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"chat and other channels are mutually exclusive (using workflow expressions, see below)"}),"\n",(0,i.jsx)(a.li,{children:"chat users have a capacity greater than 1"}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"The reason for this is; if for example voice has a capacity of 1 and chat has a capacity of 2 and there is a backlog of chat work, the agent would be locked into doing that chat work as each time a chat task is dismissed, another chat task would take its place. This means that the chat backlog would\nneed to be exhausted before the user would ever qualify for voice work."}),"\n",(0,i.jsx)(a.p,{children:"To address this, this feature toggles agents between the configured chat capacity and a chat capacity of 1, ensuring taskrouter can route the most important piece of work to the user across both channels."}),"\n",(0,i.jsx)(a.h2,{id:"flex-user-experience",children:"flex-user-experience"}),"\n",(0,i.jsx)(a.p,{children:"Example delivery of callbacks (on voice channel of capacity 1) and chat tasks (max capacity 2) where the task backlog is ordered callback, chat, callback, chat, callback, chat, callback, chat, callback"}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"alt text",src:t(20918).A+"",width:"1730",height:"1056"})}),"\n",(0,i.jsx)(a.h2,{id:"setup-and-dependencies",children:"setup and dependencies"}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(a.p,{children:"Make sure the feature is enabled in the flex-config, and the affected channel and default max capacity settings are configured as desired."}),"\n"]}),"\n",(0,i.jsxs)(a.li,{children:["\n",(0,i.jsx)(a.p,{children:"Ensure that for your workflows assigning work, they use the relevant workflow expression."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"For example for workflows assinging chat work to queues"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"worker.channel.voice.available_capacity_percentage == 100\nFor workflows assinging voice work to queues"}),"\n",(0,i.jsx)(a.li,{children:"worker.channel.chat.available_capacity_percentage == 100"}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"If other channels are in use, then modify accordingly"}),"\n",(0,i.jsx)(a.h2,{id:"how-does-it-work",children:"how does it work?"}),"\n",(0,i.jsx)(a.p,{children:"By using the workflow expressions to keep reservations of different channels mutually excluded, the solution works by moving the agents channel capacity to 1 any time they hit their max capacity, while storing the previous max capacity in local storage. Then this allows taskrouter to assign the next relevant piece of work. As soon as that work is accepted, this feature automatically puts their capacity back to the previous setting from local storage."})]})}function d(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);